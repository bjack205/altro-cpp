<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AltroCpp: altro::ilqr::iLQR&lt; n, m &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AltroCpp
   &#160;<span id="projectnumber">0.3.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealtro.html">altro</a></li><li class="navelem"><a class="el" href="namespacealtro_1_1ilqr.html">ilqr</a></li><li class="navelem"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classaltro_1_1ilqr_1_1iLQR-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">altro::ilqr::iLQR&lt; n, m &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Solve an unconstrained trajectory optimization problem using iterative LQR.  
 <a href="classaltro_1_1ilqr_1_1iLQR.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ilqr_8hpp_source.html">ilqr.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for altro::ilqr::iLQR&lt; n, m &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classaltro_1_1ilqr_1_1iLQR__coll__graph.png" border="0" usemap="#altro_1_1ilqr_1_1iLQR_3_01n_00_01m_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="altro_1_1ilqr_1_1iLQR_3_01n_00_01m_01_4_coll__map" id="altro_1_1ilqr_1_1iLQR_3_01n_00_01m_01_4_coll__map">
<area shape="rect" title="Solve an unconstrained trajectory optimization problem using iterative LQR." alt="" coords="767,78,897,119"/>
<area shape="rect" href="classaltro_1_1SolverStats.html" title="Holds statistics recorded during the solve." alt="" coords="540,56,675,83"/>
<area shape="rect" href="structaltro_1_1SolverOptions.html" title="Options for augmented Lagrangian and iLQR solvers." alt="" coords="275,5,426,32"/>
<area shape="rect" href="classaltro_1_1SolverLogger.html" title="Provides a tabular&#45;like logging output." alt="" coords="278,56,423,83"/>
<area shape="rect" href="classaltro_1_1ThreadPool.html" title="Basic threadpool that uses a single work queue." alt="" coords="541,111,674,137"/>
<area shape="rect" href="classaltro_1_1ThreadSafeQueue.html" title=" " alt="" coords="263,107,439,163"/>
<area shape="rect" href="structaltro_1_1ThreadSafeQueue_1_1Node.html" title=" " alt="" coords="5,114,181,155"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b757b335b71cc978b7edf2880e6bd58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a9b757b335b71cc978b7edf2880e6bd58">iLQR</a> (int N)</td></tr>
<tr class="separator:a9b757b335b71cc978b7edf2880e6bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1029bbe033c10fdd7f79cf89aecbd0d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a1029bbe033c10fdd7f79cf89aecbd0d3">iLQR</a> (const <a class="el" href="classaltro_1_1problem_1_1Problem.html">problem::Problem</a> &amp;prob)</td></tr>
<tr class="separator:a1029bbe033c10fdd7f79cf89aecbd0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6385180d291edb2a02072bbc72e0774c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a6385180d291edb2a02072bbc72e0774c">iLQR</a> (const <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a> &amp;other)=delete</td></tr>
<tr class="separator:a6385180d291edb2a02072bbc72e0774c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9a29de63310f6d687e3714206a5568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a1c9a29de63310f6d687e3714206a5568">operator=</a> (const <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a> &amp;other)=delete</td></tr>
<tr class="separator:a1c9a29de63310f6d687e3714206a5568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60fa4004a133bf4635d3f36d74df039"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ac60fa4004a133bf4635d3f36d74df039">iLQR</a> (<a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:ac60fa4004a133bf4635d3f36d74df039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18ab67d15aa20e937c2d6a96449798c"><td class="memTemplParams" colspan="2">template&lt;int n2 = n, int m2 = m&gt; </td></tr>
<tr class="memitem:ae18ab67d15aa20e937c2d6a96449798c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ae18ab67d15aa20e937c2d6a96449798c">CopyFromProblem</a> (const <a class="el" href="classaltro_1_1problem_1_1Problem.html">problem::Problem</a> &amp;prob, int k_start, int k_stop)</td></tr>
<tr class="memdesc:ae18ab67d15aa20e937c2d6a96449798c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the data from a Problem class into the <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html" title="Solve an unconstrained trajectory optimization problem using iterative LQR.">iLQR</a> solver.  <a href="classaltro_1_1ilqr_1_1iLQR.html#ae18ab67d15aa20e937c2d6a96449798c">More...</a><br /></td></tr>
<tr class="separator:ae18ab67d15aa20e937c2d6a96449798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1295fb57510a1eef1e9328afe3a1dd0f"><td class="memTemplParams" colspan="2">template&lt;int n2 = n, int m2 = m&gt; </td></tr>
<tr class="memitem:a1295fb57510a1eef1e9328afe3a1dd0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a1295fb57510a1eef1e9328afe3a1dd0f">InitializeFromProblem</a> (const <a class="el" href="classaltro_1_1problem_1_1Problem.html">problem::Problem</a> &amp;prob)</td></tr>
<tr class="separator:a1295fb57510a1eef1e9328afe3a1dd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b403ef5d7fcc4cdf529157ff72f9453"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a2b403ef5d7fcc4cdf529157ff72f9453">GetTrajectory</a> ()</td></tr>
<tr class="memdesc:a2b403ef5d7fcc4cdf529157ff72f9453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the trajectory.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a2b403ef5d7fcc4cdf529157ff72f9453">More...</a><br /></td></tr>
<tr class="separator:a2b403ef5d7fcc4cdf529157ff72f9453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e500a207c09d18f63b6242287f61d2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a6e500a207c09d18f63b6242287f61d2c">NumSegments</a> () const</td></tr>
<tr class="memdesc:a6e500a207c09d18f63b6242287f61d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of segments in the trajectory.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a6e500a207c09d18f63b6242287f61d2c">More...</a><br /></td></tr>
<tr class="separator:a6e500a207c09d18f63b6242287f61d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aaa45cb6b671f5c65ac2a92e0fe6cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaltro_1_1ilqr_1_1KnotPointFunctions.html">KnotPointFunctions</a>&lt; n, m &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a78aaa45cb6b671f5c65ac2a92e0fe6cd">GetKnotPointFunction</a> (int k)</td></tr>
<tr class="memdesc:a78aaa45cb6b671f5c65ac2a92e0fe6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Knot Point Function object, which contains all of the data for each knot point, including cost and dynamics expansions, feedback and feedforward gains, cost-to-go expansion, etc.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a78aaa45cb6b671f5c65ac2a92e0fe6cd">More...</a><br /></td></tr>
<tr class="separator:a78aaa45cb6b671f5c65ac2a92e0fe6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a70eb2a8c1560d176fa9141a520cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaltro_1_1SolverStats.html">SolverStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a87a70eb2a8c1560d176fa9141a520cb5">GetStats</a> ()</td></tr>
<tr class="separator:a87a70eb2a8c1560d176fa9141a520cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dde830bc48b692ff3f5533fe017eb7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classaltro_1_1SolverStats.html">SolverStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a45dde830bc48b692ff3f5533fe017eb7">GetStats</a> () const</td></tr>
<tr class="separator:a45dde830bc48b692ff3f5533fe017eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ba3a18d03af8bda53e5ca03c8805b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaltro_1_1SolverOptions.html">SolverOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a4f8ba3a18d03af8bda53e5ca03c8805b">GetOptions</a> ()</td></tr>
<tr class="separator:a4f8ba3a18d03af8bda53e5ca03c8805b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ee30207d0fed7d0506cba74c3d1bda"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structaltro_1_1SolverOptions.html">SolverOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ac1ee30207d0fed7d0506cba74c3d1bda">GetOptions</a> () const</td></tr>
<tr class="separator:ac1ee30207d0fed7d0506cba74c3d1bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79afbe16b16976db2429b3c58f2817b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a79afbe16b16976db2429b3c58f2817b7">GetCosts</a> ()</td></tr>
<tr class="separator:a79afbe16b16976db2429b3c58f2817b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5aaa4f127ffbbd906d016a7e77993ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealtro.html#abd193848a14e4b46047bef76c0e2d12a">SolverStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ae5aaa4f127ffbbd906d016a7e77993ac">GetStatus</a> () const</td></tr>
<tr class="separator:ae5aaa4f127ffbbd906d016a7e77993ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc0324e23d974fae242be87cf37a0f2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a1cc0324e23d974fae242be87cf37a0f2">GetInitialState</a> ()</td></tr>
<tr class="separator:a1cc0324e23d974fae242be87cf37a0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4909693d5fa33e7ea8b55fa3f09844"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a0a4909693d5fa33e7ea8b55fa3f09844">GetRegularization</a> ()</td></tr>
<tr class="separator:a0a4909693d5fa33e7ea8b55fa3f09844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26b628571fdddf54e6a07153dec816c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#aa26b628571fdddf54e6a07153dec816c">GetTaskAssignment</a> ()</td></tr>
<tr class="memdesc:aa26b628571fdddf54e6a07153dec816c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the assignment of the trajectory into tasks.  <a href="classaltro_1_1ilqr_1_1iLQR.html#aa26b628571fdddf54e6a07153dec816c">More...</a><br /></td></tr>
<tr class="separator:aa26b628571fdddf54e6a07153dec816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb42ec2ffde268023bb02f32346bff8c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#abb42ec2ffde268023bb02f32346bff8c">NumThreads</a> () const</td></tr>
<tr class="memdesc:abb42ec2ffde268023bb02f32346bff8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads used in the <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html" title="Solve an unconstrained trajectory optimization problem using iterative LQR.">iLQR</a> solver.  <a href="classaltro_1_1ilqr_1_1iLQR.html#abb42ec2ffde268023bb02f32346bff8c">More...</a><br /></td></tr>
<tr class="separator:abb42ec2ffde268023bb02f32346bff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7762381f83e68cc54e27140b519fa77b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a7762381f83e68cc54e27140b519fa77b">NumTasks</a> () const</td></tr>
<tr class="memdesc:a7762381f83e68cc54e27140b519fa77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks that can be executed in parallel.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a7762381f83e68cc54e27140b519fa77b">More...</a><br /></td></tr>
<tr class="separator:a7762381f83e68cc54e27140b519fa77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c4ff9e93ef35dd6164110dbd88018"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#aca9c4ff9e93ef35dd6164110dbd88018">MakeTrajectory</a> (float dt)</td></tr>
<tr class="memdesc:aca9c4ff9e93ef35dd6164110dbd88018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new zero-initialized trajectory.  <a href="classaltro_1_1ilqr_1_1iLQR.html#aca9c4ff9e93ef35dd6164110dbd88018">More...</a><br /></td></tr>
<tr class="separator:aca9c4ff9e93ef35dd6164110dbd88018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3102ef78a205abfcfea032af704a0b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a3102ef78a205abfcfea032af704a0b8a">SetTrajectory</a> (std::shared_ptr&lt; <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt;&gt; traj)</td></tr>
<tr class="memdesc:a3102ef78a205abfcfea032af704a0b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a pointer to the trajectory.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a3102ef78a205abfcfea032af704a0b8a">More...</a><br /></td></tr>
<tr class="separator:a3102ef78a205abfcfea032af704a0b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af7424893b29faf00bd5c3123be0aec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a3af7424893b29faf00bd5c3123be0aec">SetConstraintCallback</a> (const std::function&lt; double()&gt; &amp;max_violation)</td></tr>
<tr class="separator:a3af7424893b29faf00bd5c3123be0aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a021fadc7fd38ca8b9020a40ee5873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a48a021fadc7fd38ca8b9020a40ee5873">SetTaskAssignment</a> (std::vector&lt; int &gt; inds)</td></tr>
<tr class="memdesc:a48a021fadc7fd38ca8b9020a40ee5873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the division of knot points indices into parallelizable tasks.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a48a021fadc7fd38ca8b9020a40ee5873">More...</a><br /></td></tr>
<tr class="separator:a48a021fadc7fd38ca8b9020a40ee5873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8067648f427b1fe109995a5a99265924"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a8067648f427b1fe109995a5a99265924">Solve</a> ()</td></tr>
<tr class="memdesc:a8067648f427b1fe109995a5a99265924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the trajectory optimization problem using <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html" title="Solve an unconstrained trajectory optimization problem using iterative LQR.">iLQR</a>.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a8067648f427b1fe109995a5a99265924">More...</a><br /></td></tr>
<tr class="separator:a8067648f427b1fe109995a5a99265924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dd46c45c3e80dd17f803998ff07720"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a52dd46c45c3e80dd17f803998ff07720">Cost</a> ()</td></tr>
<tr class="memdesc:a52dd46c45c3e80dd17f803998ff07720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of the current trajectory.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a52dd46c45c3e80dd17f803998ff07720">More...</a><br /></td></tr>
<tr class="separator:a52dd46c45c3e80dd17f803998ff07720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad621942780d263643f25e4d043197a7f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ad621942780d263643f25e4d043197a7f">Cost</a> (const <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt; &amp;Z)</td></tr>
<tr class="separator:ad621942780d263643f25e4d043197a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed24c8360a80c2db6d86e0e987ec234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a8ed24c8360a80c2db6d86e0e987ec234">UpdateExpansions</a> ()</td></tr>
<tr class="memdesc:a8ed24c8360a80c2db6d86e0e987ec234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the cost and dynamics expansions.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a8ed24c8360a80c2db6d86e0e987ec234">More...</a><br /></td></tr>
<tr class="separator:a8ed24c8360a80c2db6d86e0e987ec234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace83bf332b0029ab8349c72faaf867f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ace83bf332b0029ab8349c72faaf867f3">BackwardPass</a> ()</td></tr>
<tr class="memdesc:ace83bf332b0029ab8349c72faaf867f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a locally optimal linear-feedback policy.  <a href="classaltro_1_1ilqr_1_1iLQR.html#ace83bf332b0029ab8349c72faaf867f3">More...</a><br /></td></tr>
<tr class="separator:ace83bf332b0029ab8349c72faaf867f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8669dce847ae7c0474132b1317fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ae9b8669dce847ae7c0474132b1317fcf">Rollout</a> ()</td></tr>
<tr class="memdesc:ae9b8669dce847ae7c0474132b1317fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate the dynamics forward from the initial state.  <a href="classaltro_1_1ilqr_1_1iLQR.html#ae9b8669dce847ae7c0474132b1317fcf">More...</a><br /></td></tr>
<tr class="separator:ae9b8669dce847ae7c0474132b1317fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feebecfca827baaaba8328db1b4cc2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a2feebecfca827baaaba8328db1b4cc2d">RolloutClosedLoop</a> (const double alpha)</td></tr>
<tr class="memdesc:a2feebecfca827baaaba8328db1b4cc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate the system forward using the feedback and feedforward gains calculated during the backward pass.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a2feebecfca827baaaba8328db1b4cc2d">More...</a><br /></td></tr>
<tr class="separator:a2feebecfca827baaaba8328db1b4cc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bbd95c8c7444216b1876373fcf70c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ad8bbd95c8c7444216b1876373fcf70c9">ForwardPass</a> ()</td></tr>
<tr class="memdesc:ad8bbd95c8c7444216b1876373fcf70c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find a better state-control trajectory.  <a href="classaltro_1_1ilqr_1_1iLQR.html#ad8bbd95c8c7444216b1876373fcf70c9">More...</a><br /></td></tr>
<tr class="separator:ad8bbd95c8c7444216b1876373fcf70c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4444b834ce6a0a02ccb5f4677526a08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a4444b834ce6a0a02ccb5f4677526a08c">UpdateConvergenceStatistics</a> ()</td></tr>
<tr class="memdesc:a4444b834ce6a0a02ccb5f4677526a08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate all the information necessary to check convergence.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a4444b834ce6a0a02ccb5f4677526a08c">More...</a><br /></td></tr>
<tr class="separator:a4444b834ce6a0a02ccb5f4677526a08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79abb47fa36c7476279eeb383b249e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#af79abb47fa36c7476279eeb383b249e1">IsDone</a> ()</td></tr>
<tr class="memdesc:af79abb47fa36c7476279eeb383b249e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the solver is done solving and can stop iterating.  <a href="classaltro_1_1ilqr_1_1iLQR.html#af79abb47fa36c7476279eeb383b249e1">More...</a><br /></td></tr>
<tr class="separator:af79abb47fa36c7476279eeb383b249e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1993ab37c0f89fa565c2c7656fcf36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#aa1993ab37c0f89fa565c2c7656fcf36c">SolveSetup</a> ()</td></tr>
<tr class="memdesc:aa1993ab37c0f89fa565c2c7656fcf36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the solver to pre-compute any needed information and be ready for a solve.  <a href="classaltro_1_1ilqr_1_1iLQR.html#aa1993ab37c0f89fa565c2c7656fcf36c">More...</a><br /></td></tr>
<tr class="separator:aa1993ab37c0f89fa565c2c7656fcf36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade83eb47a7e475b0e595e39763fedbad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ade83eb47a7e475b0e595e39763fedbad">WrapUp</a> ()</td></tr>
<tr class="memdesc:ade83eb47a7e475b0e595e39763fedbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any operations needed to return the solver to a desireable state after the iterations have stopped.  <a href="classaltro_1_1ilqr_1_1iLQR.html#ade83eb47a7e475b0e595e39763fedbad">More...</a><br /></td></tr>
<tr class="separator:ade83eb47a7e475b0e595e39763fedbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac261247377df95cc3f6fe5995cd8789b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ac261247377df95cc3f6fe5995cd8789b">NormalizedFeedforwardGain</a> ()</td></tr>
<tr class="memdesc:ac261247377df95cc3f6fe5995cd8789b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the infinity-norm of the feedforward gains, normalized by the current control values.  <a href="classaltro_1_1ilqr_1_1iLQR.html#ac261247377df95cc3f6fe5995cd8789b">More...</a><br /></td></tr>
<tr class="separator:ac261247377df95cc3f6fe5995cd8789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c205af1994d2dd1da29665efa0f445e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a5c205af1994d2dd1da29665efa0f445e">UpdateExpansionsBlock</a> (int start, int stop)</td></tr>
<tr class="separator:a5c205af1994d2dd1da29665efa0f445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a40e911b8255cf39e6f081437bcb26e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a40e911b8255cf39e6f081437bcb26e85">ResetInternalVariables</a> ()</td></tr>
<tr class="separator:a40e911b8255cf39e6f081437bcb26e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a6f6382cc4b64289762474f591b444"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a48a6f6382cc4b64289762474f591b444">ShouldRedoTaskAssignment</a> () const</td></tr>
<tr class="memdesc:a48a6f6382cc4b64289762474f591b444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the tasks need to re-assigned.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a48a6f6382cc4b64289762474f591b444">More...</a><br /></td></tr>
<tr class="separator:a48a6f6382cc4b64289762474f591b444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b31f80850eb3161d905c23a2364cb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ad4b31f80850eb3161d905c23a2364cb0">LaunchThreads</a> ()</td></tr>
<tr class="separator:ad4b31f80850eb3161d905c23a2364cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb8c1d04d20c612bb806a3fadeac722"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#aedb8c1d04d20c612bb806a3fadeac722">DefaultTaskAssignment</a> ()</td></tr>
<tr class="separator:aedb8c1d04d20c612bb806a3fadeac722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f12581976c9eb55adc7867970c6cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a00f12581976c9eb55adc7867970c6cc0">CalcIndividualCosts</a> (const <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt; &amp;Z)</td></tr>
<tr class="memdesc:a00f12581976c9eb55adc7867970c6cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of each individual knot point.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a00f12581976c9eb55adc7867970c6cc0">More...</a><br /></td></tr>
<tr class="separator:a00f12581976c9eb55adc7867970c6cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68940083145760db8ce97986fc8036e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a68940083145760db8ce97986fc8036e5">IncreaseRegularization</a> ()</td></tr>
<tr class="memdesc:a68940083145760db8ce97986fc8036e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the regularization, steering the steps closer towards gradient descent (more robust, less efficient).  <a href="classaltro_1_1ilqr_1_1iLQR.html#a68940083145760db8ce97986fc8036e5">More...</a><br /></td></tr>
<tr class="separator:a68940083145760db8ce97986fc8036e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c09baaa6d433aa7947deea983ce828f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a0c09baaa6d433aa7947deea983ce828f">DecreaseRegularization</a> ()</td></tr>
<tr class="memdesc:a0c09baaa6d433aa7947deea983ce828f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the regularization term.  <a href="classaltro_1_1ilqr_1_1iLQR.html#a0c09baaa6d433aa7947deea983ce828f">More...</a><br /></td></tr>
<tr class="separator:a0c09baaa6d433aa7947deea983ce828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a23b154f5d7ffdd529ab99de5841ed241"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a23b154f5d7ffdd529ab99de5841ed241">N_</a></td></tr>
<tr class="separator:a23b154f5d7ffdd529ab99de5841ed241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b8af1019760f87a56551fb0ffb3e6e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a42b8af1019760f87a56551fb0ffb3e6e">initial_state_</a></td></tr>
<tr class="separator:a42b8af1019760f87a56551fb0ffb3e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6d1dec9a0bdb229774e3444c2cbfd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaltro_1_1SolverStats.html">SolverStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a6d6d1dec9a0bdb229774e3444c2cbfd8">stats_</a></td></tr>
<tr class="separator:a6d6d1dec9a0bdb229774e3444c2cbfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b59f76eefb3a65b21fba8b5f0030d30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classaltro_1_1ilqr_1_1KnotPointFunctions.html">KnotPointFunctions</a>&lt; n, m &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a7b59f76eefb3a65b21fba8b5f0030d30">knotpoints_</a></td></tr>
<tr class="separator:a7b59f76eefb3a65b21fba8b5f0030d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58a16c447249a1a7065ba4ca97d45d1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#aa58a16c447249a1a7065ba4ca97d45d1">Z_</a></td></tr>
<tr class="separator:aa58a16c447249a1a7065ba4ca97d45d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6fd03016d19f5981ba02197d6d44f0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a7b6fd03016d19f5981ba02197d6d44f0">Zbar_</a></td></tr>
<tr class="separator:a7b6fd03016d19f5981ba02197d6d44f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8635005d0d2b9f980f0b001eddedfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealtro.html#abd193848a14e4b46047bef76c0e2d12a">SolverStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a9c8635005d0d2b9f980f0b001eddedfc">status_</a> = <a class="el" href="namespacealtro.html#abd193848a14e4b46047bef76c0e2d12aaea3efc995ee5453702caf3ecd090cb35">SolverStatus::kUnsolved</a></td></tr>
<tr class="separator:a9c8635005d0d2b9f980f0b001eddedfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfd47596d4be9bfe591c3406514b894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a1cfd47596d4be9bfe591c3406514b894">costs_</a></td></tr>
<tr class="separator:a1cfd47596d4be9bfe591c3406514b894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54907f11174d45092406b0279eb60f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a54907f11174d45092406b0279eb60f2d">grad_</a></td></tr>
<tr class="separator:a54907f11174d45092406b0279eb60f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0441deca6b17eecc7faa596c8d375"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a41f0441deca6b17eecc7faa596c8d375">rho_</a> = 0.0</td></tr>
<tr class="separator:a41f0441deca6b17eecc7faa596c8d375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9f81033dbedbf091d244aa8a5cfabf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a8d9f81033dbedbf091d244aa8a5cfabf">drho_</a> = 0.0</td></tr>
<tr class="separator:a8d9f81033dbedbf091d244aa8a5cfabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4d96056770a5911e1ba02c32be9bd0"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a6a4d96056770a5911e1ba02c32be9bd0">deltaV_</a></td></tr>
<tr class="separator:a6a4d96056770a5911e1ba02c32be9bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e95dbf3f43c7c11bef153e7500c07ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a3e95dbf3f43c7c11bef153e7500c07ac">is_initial_state_set</a> = false</td></tr>
<tr class="separator:a3e95dbf3f43c7c11bef153e7500c07ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdef841f0ea635f562dc5438a3b4d478"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#abdef841f0ea635f562dc5438a3b4d478">custom_work_assignment_</a> = false</td></tr>
<tr class="separator:abdef841f0ea635f562dc5438a3b4d478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8107a975c8e1a7eb90bc72c602eec"><td class="memItemLeft" align="right" valign="top">std::function&lt; double()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a34f8107a975c8e1a7eb90bc72c602eec">max_violation_callback_</a> = []() { return 0.0; }</td></tr>
<tr class="separator:a34f8107a975c8e1a7eb90bc72c602eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e0f1191bb1286d9ea5627f107a24c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a589e0f1191bb1286d9ea5627f107a24c">tasks_</a></td></tr>
<tr class="separator:a589e0f1191bb1286d9ea5627f107a24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a676594be0a3c4c6f327586945fa681"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a8a676594be0a3c4c6f327586945fa681">work_inds_</a></td></tr>
<tr class="separator:a8a676594be0a3c4c6f327586945fa681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508bad505ce0bf46a90eab9dec6af82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaltro_1_1ThreadPool.html">ThreadPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a5508bad505ce0bf46a90eab9dec6af82">pool_</a></td></tr>
<tr class="separator:a5508bad505ce0bf46a90eab9dec6af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt;<br />
class altro::ilqr::iLQR&lt; n, m &gt;</h3>

<p>Solve an unconstrained trajectory optimization problem using iterative LQR. </p>
<p>The class can be default constructed or initialized for a given number of knot points. Currently, once set, the number of knot points cannot be changed. If default-initialized, the number of knot points is pulled from the problem in the first call to <code>CopyFromProblem</code>.</p>
<p>The <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html" title="Solve an unconstrained trajectory optimization problem using iterative LQR.">iLQR</a> algorithm works taking a second-order approximation of the cost function and a first-order expansion of the dynamics. A locally-optimal feedback control policy is then constructed around the current estimate of the optimal trajectory, which is calculated using a generalization of time-varying LQR during the "backward pass". This policy is then used to simulate the system forward during the "forward pass", and the process is repeated until convergence. Since the system is simulated forward every iteration, <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html" title="Solve an unconstrained trajectory optimization problem using iterative LQR.">iLQR</a> effectively only optimizes directly over the control variables.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>Compile-time state dimension. </td></tr>
    <tr><td class="paramname">m</td><td>Compile-time control dimension. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9b757b335b71cc978b7edf2880e6bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b757b335b71cc978b7edf2880e6bd58">&#9670;&nbsp;</a></span>iLQR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::<a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1029bbe033c10fdd7f79cf89aecbd0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1029bbe033c10fdd7f79cf89aecbd0d3">&#9670;&nbsp;</a></span>iLQR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::<a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaltro_1_1problem_1_1Problem.html">problem::Problem</a> &amp;&#160;</td>
          <td class="paramname"><em>prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6385180d291edb2a02072bbc72e0774c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6385180d291edb2a02072bbc72e0774c">&#9670;&nbsp;</a></span>iLQR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::<a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a>&lt; n, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac60fa4004a133bf4635d3f36d74df039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60fa4004a133bf4635d3f36d74df039">&#9670;&nbsp;</a></span>iLQR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::<a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a>&lt; n, m &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace83bf332b0029ab8349c72faaf867f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace83bf332b0029ab8349c72faaf867f3">&#9670;&nbsp;</a></span>BackwardPass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::BackwardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a locally optimal linear-feedback policy. </p>
<p>The backward pass uses time-varying LQR to compute an optimal linear-feedback control policy. As the solve converges the constant feed-forward terms should go to zero. The solve also computes a local quadratic approximation of the cost-to-go.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The cost and dynamics expansions have already been computed using UpdateExpansions.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The feedforward and feedback gains, action-value expansion, and cost-to-go expansion terms are all updated inside the <a class="el" href="classaltro_1_1ilqr_1_1KnotPointFunctions.html" title="Stores the methods and data to evaluate various expressions at each knot point.">KnotPointFunctions</a> class for each knot point. The overall expected cost decrease is stored in deltaV_. </dd></dl>

</div>
</div>
<a id="a00f12581976c9eb55adc7867970c6cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f12581976c9eb55adc7867970c6cc0">&#9670;&nbsp;</a></span>CalcIndividualCosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::CalcIndividualCosts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the cost of each individual knot point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae18ab67d15aa20e937c2d6a96449798c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18ab67d15aa20e937c2d6a96449798c">&#9670;&nbsp;</a></span>CopyFromProblem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<div class="memtemplate">
template&lt;int n2 = n, int m2 = m&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::CopyFromProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaltro_1_1problem_1_1Problem.html">problem::Problem</a> &amp;&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the data from a Problem class into the <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html" title="Solve an unconstrained trajectory optimization problem using iterative LQR.">iLQR</a> solver. </p>
<p>Capture shared pointers to the cost and dynamics objects for each knot point, storing them in the correspoding <a class="el" href="classaltro_1_1ilqr_1_1KnotPointFunctions.html" title="Stores the methods and data to evaluate various expressions at each knot point.">KnotPointFunctions</a> object.</p>
<p>Assumes both the problem and the solver have the number of knot points.</p>
<p>Allows for a subset of the knot points to be copied, since in the future this method might be used to specify compile-time sizes for hybrid / switched dynamics.</p>
<p>Appends the knotpoints to those currently in the solver.</p>
<p>Captures the initial state from the problem as a shared pointer, so the initial state of the solver is changed by modifying the initial state of the original problem.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n2</td><td>Compile-time state dimension. Can be Eigen::Dynamic (-1) </td></tr>
    <tr><td class="paramname">m2</td><td>Compile-time control dimension. Can be Eigen::Dynamic (-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prob</td><td><a class="el" href="classaltro_1_1Trajectory.html" title="Represents a state and control trajectory.">Trajectory</a> optimization problem </td></tr>
    <tr><td class="paramname">k_start</td><td>Starting index (inclusive) for data to copy. 0 &lt;= k_start &lt; N+1 </td></tr>
    <tr><td class="paramname">k_stop</td><td>Terminal index (exclusive) for data to copy. 0 &lt; k_stop &lt;= N+1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52dd46c45c3e80dd17f803998ff07720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dd46c45c3e80dd17f803998ff07720">&#9670;&nbsp;</a></span>Cost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::Cost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the cost of the current trajectory. </p>
<p>By default, it will use the current guess stored in the solver, but it can be passed any compatible trajectory.</p>
<dl class="section return"><dt>Returns</dt><dd>double The current cost </dd></dl>

</div>
</div>
<a id="ad621942780d263643f25e4d043197a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad621942780d263643f25e4d043197a7f">&#9670;&nbsp;</a></span>Cost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::Cost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c09baaa6d433aa7947deea983ce828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c09baaa6d433aa7947deea983ce828f">&#9670;&nbsp;</a></span>DecreaseRegularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::DecreaseRegularization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease the regularization term. </p>

</div>
</div>
<a id="aedb8c1d04d20c612bb806a3fadeac722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb8c1d04d20c612bb806a3fadeac722">&#9670;&nbsp;</a></span>DefaultTaskAssignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::DefaultTaskAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8bbd95c8c7444216b1876373fcf70c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bbd95c8c7444216b1876373fcf70c9">&#9670;&nbsp;</a></span>ForwardPass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::ForwardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to find a better state-control trajectory. </p>
<p>Using the feedback policy computed during the backward pass, simulate the system forward and make sure the resulting trajectory decreases the overall cost and make sufficient progress towards a local minimum (via pseudo Wolfe conditions).</p>
<dl class="section post"><dt>Postcondition</dt><dd>The current trajectory candidate Z_ is updated with the new guess. </dd></dl>

</div>
</div>
<a id="a79afbe16b16976db2429b3c58f2817b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79afbe16b16976db2429b3c58f2817b7">&#9670;&nbsp;</a></span>GetCosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a>&amp; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetCosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cc0324e23d974fae242be87cf37a0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc0324e23d974fae242be87cf37a0f2">&#9670;&nbsp;</a></span>GetInitialState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a>&gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetInitialState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78aaa45cb6b671f5c65ac2a92e0fe6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aaa45cb6b671f5c65ac2a92e0fe6cd">&#9670;&nbsp;</a></span>GetKnotPointFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1ilqr_1_1KnotPointFunctions.html">KnotPointFunctions</a>&lt;n, m&gt;&amp; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetKnotPointFunction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Knot Point Function object, which contains all of the data for each knot point, including cost and dynamics expansions, feedback and feedforward gains, cost-to-go expansion, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>knot point index, 0 &lt;= k &lt;= N_ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the <a class="el" href="classaltro_1_1ilqr_1_1KnotPointFunctions.html" title="Stores the methods and data to evaluate various expressions at each knot point.">KnotPointFunctions</a> class </dd></dl>

</div>
</div>
<a id="a4f8ba3a18d03af8bda53e5ca03c8805b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ba3a18d03af8bda53e5ca03c8805b">&#9670;&nbsp;</a></span>GetOptions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaltro_1_1SolverOptions.html">SolverOptions</a>&amp; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1ee30207d0fed7d0506cba74c3d1bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ee30207d0fed7d0506cba74c3d1bda">&#9670;&nbsp;</a></span>GetOptions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structaltro_1_1SolverOptions.html">SolverOptions</a>&amp; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a4909693d5fa33e7ea8b55fa3f09844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4909693d5fa33e7ea8b55fa3f09844">&#9670;&nbsp;</a></span>GetRegularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetRegularization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87a70eb2a8c1560d176fa9141a520cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a70eb2a8c1560d176fa9141a520cb5">&#9670;&nbsp;</a></span>GetStats() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1SolverStats.html">SolverStats</a>&amp; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45dde830bc48b692ff3f5533fe017eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dde830bc48b692ff3f5533fe017eb7">&#9670;&nbsp;</a></span>GetStats() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classaltro_1_1SolverStats.html">SolverStats</a>&amp; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5aaa4f127ffbbd906d016a7e77993ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5aaa4f127ffbbd906d016a7e77993ac">&#9670;&nbsp;</a></span>GetStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealtro.html#abd193848a14e4b46047bef76c0e2d12a">SolverStatus</a> <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa26b628571fdddf54e6a07153dec816c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26b628571fdddf54e6a07153dec816c">&#9670;&nbsp;</a></span>GetTaskAssignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt;&amp; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetTaskAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the assignment of the trajectory into tasks. </p>
<p>A task is defined by a set of consecutive knot point indices whose expansions will be processed serially. Although all knot points can be processed in parallel, it's usually better to "chunk" the trajectory into the number of available parallel processors.</p>
<p>Most users will not need to consume this information.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt;&amp; A vector of strictly increasing knot point indices. Each tasks processes knotpoints in the interval [<code>inds[k]</code>, <code>inds[k+1]</code>), where <code>inds[0] = 0</code> and inds.back() = N+1`. </dd></dl>

</div>
</div>
<a id="a2b403ef5d7fcc4cdf529157ff72f9453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b403ef5d7fcc4cdf529157ff72f9453">&#9670;&nbsp;</a></span>GetTrajectory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt;n, m&gt; &gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::GetTrajectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the trajectory. </p>

</div>
</div>
<a id="a68940083145760db8ce97986fc8036e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68940083145760db8ce97986fc8036e5">&#9670;&nbsp;</a></span>IncreaseRegularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::IncreaseRegularization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the regularization, steering the steps closer towards gradient descent (more robust, less efficient). </p>

</div>
</div>
<a id="a1295fb57510a1eef1e9328afe3a1dd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1295fb57510a1eef1e9328afe3a1dd0f">&#9670;&nbsp;</a></span>InitializeFromProblem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<div class="memtemplate">
template&lt;int n2 = n, int m2 = m&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::InitializeFromProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaltro_1_1problem_1_1Problem.html">problem::Problem</a> &amp;&#160;</td>
          <td class="paramname"><em>prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af79abb47fa36c7476279eeb383b249e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79abb47fa36c7476279eeb383b249e1">&#9670;&nbsp;</a></span>IsDone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::IsDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the solver is done solving and can stop iterating. </p>
<p>The solver can exit because it has successfully converged or because it has entered a bad state and needs to exit.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the solver should stop iterating </dd></dl>

</div>
</div>
<a id="ad4b31f80850eb3161d905c23a2364cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b31f80850eb3161d905c23a2364cb0">&#9670;&nbsp;</a></span>LaunchThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::LaunchThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca9c4ff9e93ef35dd6164110dbd88018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9c4ff9e93ef35dd6164110dbd88018">&#9670;&nbsp;</a></span>MakeTrajectory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt;n, m&gt; &gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::MakeTrajectory </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new zero-initialized trajectory. </p>
<p>Assumes a uniform time step. The trajectory is automatically linked to the solver and is used both as the initial guess and as the storage location for the optimized solution during and after the solve.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>Time step used in the trajectory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;Trajectory&lt;n, m&gt;&gt; A new zero-initialized trajectory. </dd></dl>

</div>
</div>
<a id="ac261247377df95cc3f6fe5995cd8789b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac261247377df95cc3f6fe5995cd8789b">&#9670;&nbsp;</a></span>NormalizedFeedforwardGain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::NormalizedFeedforwardGain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the infinity-norm of the feedforward gains, normalized by the current control values. </p>
<p>Provides an approximation to the gradient of the Lagrangian.</p>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

</div>
</div>
<a id="a6e500a207c09d18f63b6242287f61d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e500a207c09d18f63b6242287f61d2c">&#9670;&nbsp;</a></span>NumSegments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::NumSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of segments in the trajectory. </p>

</div>
</div>
<a id="a7762381f83e68cc54e27140b519fa77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7762381f83e68cc54e27140b519fa77b">&#9670;&nbsp;</a></span>NumTasks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::NumTasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks that can be executed in parallel. </p>
<p>Controlled via <code>AssignWork</code>. </p>

</div>
</div>
<a id="abb42ec2ffde268023bb02f32346bff8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb42ec2ffde268023bb02f32346bff8c">&#9670;&nbsp;</a></span>NumThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::NumThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads used in the <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html" title="Solve an unconstrained trajectory optimization problem using iterative LQR.">iLQR</a> solver. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of threads </dd></dl>

</div>
</div>
<a id="a1c9a29de63310f6d687e3714206a5568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9a29de63310f6d687e3714206a5568">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a>&amp; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">iLQR</a>&lt; n, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40e911b8255cf39e6f081437bcb26e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e911b8255cf39e6f081437bcb26e85">&#9670;&nbsp;</a></span>ResetInternalVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::ResetInternalVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b8669dce847ae7c0474132b1317fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b8669dce847ae7c0474132b1317fcf">&#9670;&nbsp;</a></span>Rollout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::Rollout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simulate the dynamics forward from the initial state. </p>
<p>By default it will simulate the system forward open-loop. </p>

</div>
</div>
<a id="a2feebecfca827baaaba8328db1b4cc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feebecfca827baaaba8328db1b4cc2d">&#9670;&nbsp;</a></span>RolloutClosedLoop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::RolloutClosedLoop </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simulate the system forward using the feedback and feedforward gains calculated during the backward pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Line search parameter, 0 &lt; alpha &lt;= 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the the state and control bounds are not violated. </dd></dl>

</div>
</div>
<a id="a3af7424893b29faf00bd5c3123be0aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af7424893b29faf00bd5c3123be0aec">&#9670;&nbsp;</a></span>SetConstraintCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::SetConstraintCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double()&gt; &amp;&#160;</td>
          <td class="paramname"><em>max_violation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48a021fadc7fd38ca8b9020a40ee5873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a021fadc7fd38ca8b9020a40ee5873">&#9670;&nbsp;</a></span>SetTaskAssignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::SetTaskAssignment </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>inds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the division of knot points indices into parallelizable tasks. </p>
<p>Defines groups of consecutive knotpoints that should be processed in series as a single task. Each group can then be run independently and in parallel. For best performance, the number of tasks should be equal to the number of available cores.</p>
<p>Once this is set, the solver will no longer automatically adjust the number of tasks if the number of requested threads (via <code><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a4f8ba3a18d03af8bda53e5ca03c8805b">GetOptions()</a>.nthreads</code>) or tasks per thread (via <code><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a4f8ba3a18d03af8bda53e5ca03c8805b">GetOptions()</a>.tasks_per_thread</code>) changes. changes. Is is the user's responsibility to modify this as needed once set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inds</td><td>A strictly increasing vector of knot point indices. For a vector of length N, it defines N-1 tasks, where each task processes indices in the interval [<code>inds[i]</code>, <code>inds[i+1]</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3102ef78a205abfcfea032af704a0b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3102ef78a205abfcfea032af704a0b8a">&#9670;&nbsp;</a></span>SetTrajectory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::SetTrajectory </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt; n, m &gt;&gt;&#160;</td>
          <td class="paramname"><em>traj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a pointer to the trajectory. </p>
<p>This trajectory will be used as the initial guess and will also be the storage location for the optimized trajectory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traj</td><td>Pointer to the trajectory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48a6f6382cc4b64289762474f591b444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a6f6382cc4b64289762474f591b444">&#9670;&nbsp;</a></span>ShouldRedoTaskAssignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::ShouldRedoTaskAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the tasks need to re-assigned. </p>
<p>Will not overrite tasks once they have been assigned manually via <code><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a48a021fadc7fd38ca8b9020a40ee5873" title="Set the division of knot points indices into parallelizable tasks.">SetTaskAssignment()</a></code>. </p>

</div>
</div>
<a id="a8067648f427b1fe109995a5a99265924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8067648f427b1fe109995a5a99265924">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::Solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the trajectory optimization problem using <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html" title="Solve an unconstrained trajectory optimization problem using iterative LQR.">iLQR</a>. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The provided trajectory is overwritten with a locally-optimal dynamically-feasible trajectory. The solver status and statistics, obtained via <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#ae5aaa4f127ffbbd906d016a7e77993ac">GetStatus()</a> and <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a87a70eb2a8c1560d176fa9141a520cb5">GetStats()</a> are updated. The solve is successful if <code>GetStatus == SolverStatus::kSuccess</code>. </dd></dl>

</div>
</div>
<a id="aa1993ab37c0f89fa565c2c7656fcf36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1993ab37c0f89fa565c2c7656fcf36c">&#9670;&nbsp;</a></span>SolveSetup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::SolveSetup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the solver to pre-compute any needed information and be ready for a solve. </p>
<p>This method should ensure the solver enters a reproducible state prior to each solve, so that the <code><a class="el" href="classaltro_1_1ilqr_1_1iLQR.html#a8067648f427b1fe109995a5a99265924" title="Solve the trajectory optimization problem using iLQR.">Solve()</a></code> method can be called multiple times. </p>

</div>
</div>
<a id="a4444b834ce6a0a02ccb5f4677526a08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4444b834ce6a0a02ccb5f4677526a08c">&#9670;&nbsp;</a></span>UpdateConvergenceStatistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::UpdateConvergenceStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate all the information necessary to check convergence. </p>
<p>Calculates the gradient, change in cost, etc. Updates the solver statistics accordingly.</p>
<dl class="section post"><dt>Postcondition</dt><dd>Increments the number of solver iterations </dd></dl>

</div>
</div>
<a id="a8ed24c8360a80c2db6d86e0e987ec234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed24c8360a80c2db6d86e0e987ec234">&#9670;&nbsp;</a></span>UpdateExpansions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::UpdateExpansions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the cost and dynamics expansions. </p>
<p>NOTE: Also calculates the cost for each knot point.</p>
<p>Computes the first and second order expansions of the cost and dynamics, storing the results in the <a class="el" href="classaltro_1_1ilqr_1_1KnotPointFunctions.html" title="Stores the methods and data to evaluate various expressions at each knot point.">KnotPointFunctions</a> class for each knot point.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The trajectory must set to the next guess for the optimal trajectory. The trajectory cannot be a nullptr, and must be set via SetTrajectory.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The expansions are updated for knotpoints_[k], 0 &lt;= k &lt; N_ </dd></dl>

</div>
</div>
<a id="a5c205af1994d2dd1da29665efa0f445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c205af1994d2dd1da29665efa0f445e">&#9670;&nbsp;</a></span>UpdateExpansionsBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::UpdateExpansionsBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade83eb47a7e475b0e595e39763fedbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade83eb47a7e475b0e595e39763fedbad">&#9670;&nbsp;</a></span>WrapUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::WrapUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any operations needed to return the solver to a desireable state after the iterations have stopped. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1cfd47596d4be9bfe591c3406514b894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfd47596d4be9bfe591c3406514b894">&#9670;&nbsp;</a></span>costs_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a> <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::costs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdef841f0ea635f562dc5438a3b4d478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdef841f0ea635f562dc5438a3b4d478">&#9670;&nbsp;</a></span>custom_work_assignment_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::custom_work_assignment_ = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a4d96056770a5911e1ba02c32be9bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4d96056770a5911e1ba02c32be9bd0">&#9670;&nbsp;</a></span>deltaV_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;double, 2&gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::deltaV_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d9f81033dbedbf091d244aa8a5cfabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9f81033dbedbf091d244aa8a5cfabf">&#9670;&nbsp;</a></span>drho_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::drho_ = 0.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54907f11174d45092406b0279eb60f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54907f11174d45092406b0279eb60f2d">&#9670;&nbsp;</a></span>grad_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a> <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::grad_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42b8af1019760f87a56551fb0ffb3e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b8af1019760f87a56551fb0ffb3e6e">&#9670;&nbsp;</a></span>initial_state_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="namespacealtro.html#aebcd2179a0c7d0ee8679bdf910930242">VectorXd</a>&gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::initial_state_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e95dbf3f43c7c11bef153e7500c07ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e95dbf3f43c7c11bef153e7500c07ac">&#9670;&nbsp;</a></span>is_initial_state_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::is_initial_state_set = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b59f76eefb3a65b21fba8b5f0030d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b59f76eefb3a65b21fba8b5f0030d30">&#9670;&nbsp;</a></span>knotpoints_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="classaltro_1_1ilqr_1_1KnotPointFunctions.html">KnotPointFunctions</a>&lt;n, m&gt; &gt; &gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::knotpoints_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34f8107a975c8e1a7eb90bc72c602eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f8107a975c8e1a7eb90bc72c602eec">&#9670;&nbsp;</a></span>max_violation_callback_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;double()&gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::max_violation_callback_ = []() { return 0.0; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23b154f5d7ffdd529ab99de5841ed241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b154f5d7ffdd529ab99de5841ed241">&#9670;&nbsp;</a></span>N_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::N_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5508bad505ce0bf46a90eab9dec6af82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508bad505ce0bf46a90eab9dec6af82">&#9670;&nbsp;</a></span>pool_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1ThreadPool.html">ThreadPool</a> <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::pool_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41f0441deca6b17eecc7faa596c8d375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f0441deca6b17eecc7faa596c8d375">&#9670;&nbsp;</a></span>rho_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::rho_ = 0.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d6d1dec9a0bdb229774e3444c2cbfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6d1dec9a0bdb229774e3444c2cbfd8">&#9670;&nbsp;</a></span>stats_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaltro_1_1SolverStats.html">SolverStats</a> <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::stats_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c8635005d0d2b9f980f0b001eddedfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8635005d0d2b9f980f0b001eddedfc">&#9670;&nbsp;</a></span>status_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealtro.html#abd193848a14e4b46047bef76c0e2d12a">SolverStatus</a> <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::status_ = <a class="el" href="namespacealtro.html#abd193848a14e4b46047bef76c0e2d12aaea3efc995ee5453702caf3ecd090cb35">SolverStatus::kUnsolved</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a589e0f1191bb1286d9ea5627f107a24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e0f1191bb1286d9ea5627f107a24c">&#9670;&nbsp;</a></span>tasks_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::function&lt;void()&gt; &gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::tasks_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a676594be0a3c4c6f327586945fa681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a676594be0a3c4c6f327586945fa681">&#9670;&nbsp;</a></span>work_inds_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::work_inds_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa58a16c447249a1a7065ba4ca97d45d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58a16c447249a1a7065ba4ca97d45d1">&#9670;&nbsp;</a></span>Z_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt;n, m&gt; &gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::Z_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b6fd03016d19f5981ba02197d6d44f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6fd03016d19f5981ba02197d6d44f0">&#9670;&nbsp;</a></span>Zbar_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n = Eigen::Dynamic, int m = Eigen::Dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classaltro_1_1Trajectory.html">Trajectory</a>&lt;n, m&gt; &gt; <a class="el" href="classaltro_1_1ilqr_1_1iLQR.html">altro::ilqr::iLQR</a>&lt; n, m &gt;::Zbar_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/altro-cpp/altro-cpp/altro/ilqr/<a class="el" href="ilqr_8hpp_source.html">ilqr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
